package org.miaomiao.assembly.model;

import org.miaomiao.assembly.LoadException;
import org.miaomiao.loader.InputStreamReader;
import org.miaomiao.util.Logger;

import java.io.IOException;

public class CLRuntimeHeader extends BaseDataModel {

    Logger logger;

    /**
     * 0 4
     * Size of the header in bytes.
     */
    private long cb;
    /**
     * 4 2
     * Major number of the minimum version of the runtime required to run the program.
     */
    private int majorRuntimeVersion;
    /**
     * 6 2
     * Minor number of the version of the runtime required to run the program.
     */
    private int minorRuntimeVersion;
    /**
     * 8 8
     * RVA and size of the metadata.
     */
    private RVAAndSize metaData;
    /**
     * 16 4
     * Binary flags, discussed in the following section. In ILAsm, you can specify this value explicitly by the directive .corflags <integer value> and/or the command- line option /FLAGS=<integer value>. The command-line option takes precedence over the directive.
     */
    private long flags;
    /**
     * 20 4
     * EntryPointToken/EntryPointRVA
     * Metadata identifier (token) of the entry point for the image file; can be 0 for DLL images. This field identifies a method belonging to this module or a module containing the entry point method. In images of version 2.0 and newer, this field may contain RVA of the embedded native entry point method.
     * The EntryPointToken field of the common language runtime header contains a token (meta- data identifier) of either a method definition (MethodDef) or a file reference (File). A MethodDef token identifies a method defined in the module (a managed PE file) as the entry point method. A File token is used in one case only: in the runtime header of the prime module of a multi- module assembly, when the entry point method is defined in another module (identified by the file reference) of this assembly. In this case, the module identified by the file reference must contain the respective MethodDef token in the EntryPointToken field of its runtime header.
     * EntryPointToken must be specified in runnable executables (EXE files). The IL assembler, for example, does not even try to generate an EXE file if the source code does not define the entry point. The CLR loader imposes limitations on the signature of the entry point method: the method must return a signed or unsigned 4-byte integer or void, and it must have at most one parameter of type string or string[] (vector of strings).
     * With nonrunnable executables (DLL files), it’s a different story. Pure-IL DLLs don’t need the entry point method defined, and the EntryPointToken field in their runtime headers should be set to 0.
     * Mixed-code DLLs—DLLs containing IL and embedded unmanaged code—generated by the VC++ compiler and linker must run the unmanaged native function DllMain immediately at the DLL invocation in order to perform the initialization necessary for the unmanaged native components of the DLL. The signature of this unmanaged function must be as follows:
     * int DllMain(HINSTANCE, DWORD, void *);
     * To be visible from the managed code and the runtime, the function DllMain must be declared as a platform invocation of an embedded native method (local P/Invoke, also known in enlightened circles as IJW—It Just Works). See Chapter 18 for details about the interopera- tion of managed and unmanaged code.
     * Starting with version 2.0, you can specify the unmanaged entry point method without local platform invocation. In this case, indicated by setting flag COMIMAGE_FLAGS_NATIVE_ENTRYPOINT, the field EntryPointRVA (alias of EntryPointTo- ken) contains the RVA of the native entry point method.
     * The method referred to by the EntryPointToken/EntryPointRVA field of the common lan- guage runtime header has nothing to do with the function to which the AddressOfEntryPoint field of the PE header points. AddressOfEntryPoint always points to the runtime invocation stub, which is invisible to the runtime, is not reflected in metadata and hence cannot have a token.
     */
    private long entryPoint;
    /**
     * 24 8
     * RVA and size of managed resources.
     */
    private RVAAndSize resources;
    /**
     * 32 8
     * RVA and size of the hash data for this PE file, used by the loader for binding and versioning.
     */
    private RVAAndSize strongNameSignature;
    /**
     * 40 8
     * RVA and size of the Code Manager table. In the existing releases of the runtime, this field is reserved and must be set to 0.
     */
    private RVAAndSize codeManagerTable;
    /**
     * 48 8
     * RVA and size in bytes of an array of virtual table (v-table) fixups. Among current managed compilers, only the VC++ linker and the IL assembler can produce this array.
     */
    private RVAAndSize vTableFixups;
    /**
     * 56 8
     * RVA and size of an array of addresses of jump thunks. Among managed compilers, only the VC++ of versions pre-8.0 could produce this table, which allows the export of unmanaged native methods embedded in the managed PE file. In v2.0 of CLR this entry is obsolete and must be set to 0.
     */
    private RVAAndSize exportAddressTableJumps;
    /**
     * 64 8
     * Reserved for precompiled images; set to 0.
     */
    private long managedNativeHeader;

    /**
     * The image file contains IL code only, with no embedded native unmanaged code except the start-up stub (which simply executes an indirect jump to the CLR entry point). Common language runtime–aware operating sys- tems (such as Windows XP and newer) ignore the start-up stub and invoke the CLR automatically, so for all practical purposes the file can be considered pure IL. However, setting this flag can cause certain problems when running under Windows XP and newer. If this flag is set, the OS loader of Windows XP and newer ignores not only the start-up stub but also the .reloc section, which in this case contains single relocation (or single pair of relocations in IA64-specific images) for the CLR entry point. However, the .reloc section can contain relocations for the beginning and end of the .tls section as well as relocations for what is referred to as data on data (that is, data constants that are pointers to other data constants). Among existing managed compilers, only the VC++ and the IL assembler can produce these items. The VC++ of v7.0 and v7.1 (corresponding to CLR versions 1.0 and 1.1) never set this flag because the image file it generated was never pure IL. In v2.0 this situation has changed, and currently, the VC++ and IL assembler are the only two capable of producing pure-IL image files that might require additional relocations in the .reloc section. To resolve this problem, the IL assembler, if TLS-based data or data on data is emitted, clears this flag and, if the target platform is 32-bit, sets the COMIMAGE_FLAGS_32BITREQUIRED flag instead.
     */
    public static final int Flag_COMIMAGE_FLAGS_ILONLY = 0x00000001;
    /**
     * The image file can be loaded only into a 32-bit process. This flag is set alone when native unmanaged code is embedded in the PE file or when the .reloc section contains additional relocations or is set in combina- tion with _ILONLY when the executable does not contain additional relocations but is in some way 32-bit specific (for example, invokes an unmanaged 32-bit specific API or uses 4-byte integers to store pointers).
     */
    public static final int Flag_COMIMAGE_FLAGS_32BITREQUIRED = 0x00000002;
    /**
     * This flag is obsolete and should not be set. Setting it—as the IL assembler allows, using the .corflags directive—will render your module unloadable.
     */
    public static final int Flag_COMIMAGE_FLAGS_IL_LIBRARY = 0x00000004;
    /**
     * The image file is protected with a strong name signature. The strong name signature includes the public key and the signature hash and is a part of an assembly’s identity, along with the assembly name, ver- sion number, and culture information. This flag is set when the strong name signing procedure is applied to the image file. No compiler, including ILAsm, can set this flag explicitly.
     */
    public static final int Flag_COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x00000008;
    /**
     * The executable’s entry point is an unmanaged method. The EntryPointToken/EntryPointRVA field of the CLR header contains the RVA of this native method. This flag was introduced in version 2.0 of the CLR.
     */
    public static final int Flag_COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 0x00000010;
    /**
     * The CLR loader and the JIT com- piler are required to track debug information about the methods. This flag is not used.
     */
    public static final int Flag_COMIMAGE_FLAGS_TRACKDEBUGDATA = 0x00010000;

    @Override
    public void parse(InputStreamReader reader) throws IOException, LoadException {
        this.cb = reader.readUnsignedInt();
        this.majorRuntimeVersion = reader.readUnsignedShort();
        this.minorRuntimeVersion = reader.readUnsignedShort();

        if (this.metaData == null) {
            this.metaData = new RVAAndSize();
        }
        this.metaData.parse(reader);

        this.flags = reader.readUnsignedInt();
        this.entryPoint = reader.readUnsignedInt();

        if (this.resources == null) {
            this.resources = new RVAAndSize();
        }
        this.resources.parse(reader);

        if (this.strongNameSignature == null) {
            this.strongNameSignature = new RVAAndSize();
        }
        this.strongNameSignature.parse(reader);

        if (this.codeManagerTable == null) {
            this.codeManagerTable = new RVAAndSize();
        }
        this.codeManagerTable.parse(reader);

        if (this.vTableFixups == null) {
            this.vTableFixups = new RVAAndSize();
        }
        this.vTableFixups.parse(reader);

        if (this.exportAddressTableJumps == null) {
            this.exportAddressTableJumps = new RVAAndSize();
        }
        this.exportAddressTableJumps.parse(reader);

        this.managedNativeHeader = reader.readUnsignedLong();
        assert (managedNativeHeader == 0);
        
        logger.debug("at position %d",reader.getPosition());
    }

    public long getCb() {
        return cb;
    }

    public int getMajorRuntimeVersion() {
        return majorRuntimeVersion;
    }

    public int getMinorRuntimeVersion() {
        return minorRuntimeVersion;
    }

    public RVAAndSize getMetaData() {
        return metaData;
    }

    public long getFlags() {
        return flags;
    }

    public long getEntryPoint() {
        return entryPoint;
    }

    public RVAAndSize getResources() {
        return resources;
    }

    public RVAAndSize getStrongNameSignature() {
        return strongNameSignature;
    }

    public RVAAndSize getCodeManagerTable() {
        return codeManagerTable;
    }

    public RVAAndSize getvTableFixups() {
        return vTableFixups;
    }

    public RVAAndSize getExportAddressTableJumps() {
        return exportAddressTableJumps;
    }

    public long getManagedNativeHeader() {
        return managedNativeHeader;
    }

}
